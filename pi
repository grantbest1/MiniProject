#This code will be used to determine which quadrant the marker is in.
from picamera.array import PiRGBArray
from picamera import PiCamera
import cv2
from cv2 import aruco
import numpy
import math
import time

quad = 0
desired = "0.00"
prevquad = 5
camera = PiCamera()
rawCapture = PiRGBArray(camera)
camera.iso = 100
time.sleep(2)
camera.shutter_speed = camera.exposure_speed
camera.exposure_mode = 'off'
gain = camera.awb_gains
camera.awb_mode = 'off'
camera.awb_gains = gain
time.sleep(0.1)
aruco_dictionary = aruco.Dictionary_get(aruco.DICT_6X6_250)
parameters = aruco.DetectorParameters_create()
#The above code has been taken from previous assingments to set up the camera.
#The below code will be using aruco marker detection in order to figure out what quadrant it is. The project description 4.5 says to use aruco marker detection
#In order to figure how to use aruco marker detection, I used this website:https://docs.opencv.org/4.5.3/d5/dae/tutorial_aruco_detection.html
def computervision():
    global quad
    global desired
    marker_found = False
    camera.capture(rawCapture, format = "bgr")
    image = rawCapture.array
    display = rawCapture.array
    cv2.cvtColor(image,cv2.COLOR_RGB2GRAY)
    corners,ids,rejectedImgPoints = aruco.detectMarkers(image,aruco_dictionary, parameters=parameters)
    if type(ids) == numpy.ndarray:
        marker_found = True
        output_array = numpy.ndarray(len(ids))
        index = 0
        for i in ids:
            for j in i:
                xdirection1 =(corners[index][0][1][0] + corners[index][0][0][0])/2
                xdirection2 = (corners[index][0][2][0] + corners[index][0][3][0])/2
                xcenter = (xdirection1 + xdirection2)/2
                ydirection1 = (corners[index][0][1][1] + corners[index][0][2][1])/2
                ydirection2 = (corners[index][0][3][1] + corners[index][0][0][1])/2
                ycenter = (ydirection1 + ydirection2)/2
                Xmiddleofimage = image.shape[1]/2
                Ymiddleofimage = image.shape[0]/2
                if xcenter > Xmiddleofimage and ycenter > Ymiddleofimage:
                    quadrant = 1
                    desired = "0"
                    print("This is the quadrant: ", quadrant)
                if xcenter < Xmiddleofimage and ycenter > Ymiddleofimage:
                    quadrant = 2
                    desired = "1.57"
                    print("This is the quadrant: ", quadrant)
                if xcenter < Xmiddleofimage and ycenter < Ymiddleofimage:
                    quadrant = 3
                    desired = "3.14"
                    print("This is the quadrant: ", quadrant)
                if xcenter > Xmiddleofimage and ycenter <Ymiddleofimage:
                    quadrant = 4
                    desired = "4.71"
                    print("This is the quadrant: ", quadrant)
                output_array[index] = j
                index +=1
    rawCapture.truncate(0)
    if marker_found == False:
        print("No markers found")
        
        import smbus
import time
import board
import busio
import adafruit_character_lcd.character_lcd_rgb_i2c as character_lcd

#for RPI version 1, use “bus = smbus.SMBus(0)”
bus = smbus.SMBus(1)

# Modify this if you have a different sized Character LCD
columns = 16
rows = 2

# Initialise I2C bus.
i2c = busio.I2C(board.SCL,board.SDA)  

# Initialise the LCD class
lcd = character_lcd.Character_LCD_RGB_I2C(i2c, columns, rows)

lcd.clear()
#this is the address we setup in the Arduino Program
address = 0x04

def writePosition(value):
    bus.write_byte(address, value)
    return -1

def readPosition():
    number = bus.read_byte(address)
    return number

def systemIntegration():
    #while True:
        #position will be the number being sent to the arduino from the camera
        old_position = 0
        position = quadrant
        #if not position:
            #continue
        if position == old_position:
            print ("Already at position ", position)
            lcd.color = [0,0,100]
            lcd.text_direction = lcd.LEFT_TO_RIGHT
            lcd.message = "Already at pos.\n " + str(position)
            #sleep one second
            time.sleep(2)
            lcd.clear()
        else:
            writePosition(position)
            print ("RPI: Arduino, move to position ", position)
            lcd.color = [100,0,0]
            lcd.text_direction = lcd.LEFT_TO_RIGHT
            lcd.message = "Move to pos. " + str(position)
            #sleep one second
            time.sleep(2)
            lcd.clear()

            number = readPosition()
            #This is currently not needed I don't think but I don't wanna forget
            #if number != old_position:
#                print ("Arduino I moved back to ", old_position)
#                lcd.color = [0,100,0]
 #               lcd.text_direction = lcd.LEFT_TO_RIGHT
#                lcd.message = "Moved back to\n pos. " + str(number)
#                time.sleep(2)
#
            print ("Arduino: Hey RPI, I moved to ", position)
            lcd.color = [0,100,0]
            lcd.text_direction = lcd.LEFT_TO_RIGHT
            lcd.message = "Moved to pos. " + str(number)
            time.sleep(2)
            lcd.clear()
            lcd.color = [0,0,0]
            old_position = position
                                                                               

        
while 1 ==1:
    computervision()
                
